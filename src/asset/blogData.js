export const blogDatas =
{
  "@version": "2.0",
  "channel": {
    "title": "potter.log",
    "link": [
      "https://velog.io/",
      {
        "@href": "https://v2.velog.io/rss/potter",
        "@rel": "self",
        "@type": "application/rss+xml"
      }
    ],
    "description": "코딩에서 인생을 배우다.",
    "lastBuildDate": "Thu, 28 Jan 2021 06:27:45 GMT",
    "docs": "https://validator.w3.org/feed/docs/rss2.html",
    "generator": "https://github.com/jpmonette/feed",
    "image": {
      "title": "potter.log",
      "url": "https://images.velog.io/images/potter/profile/34c891d2-a0d4-40e5-949a-f552c0bc1cf9/KakaoTalk_Image_2020-07-28-19-17-38 복사본.jpeg",
      "link": "https://velog.io/"
    },
    "copyright": "Copyright (C) 2019. potter.log. All rights reserved.",
    "item": [
      {
        "title": "함수형 컴포넌트 vs Class 컴포넌트  상태관리 주의점(useState vs setState)",
        "link": "https://velog.io/@potter/Class-vs-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EC%A3%BC%EC%9D%98%EC%A0%90useState-vs-setState",
        "guid": "https://velog.io/@potter/Class-vs-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EC%A3%BC%EC%9D%98%EC%A0%90useState-vs-setState",
        "pubDate": "Thu, 28 Jan 2021 06:27:45 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/e836d5f6-c2e8-411c-9169-32ce44f9e734/reactintroduction.png\" alt=\"\"><\/p><h1 id=\"☠️-함수형-컴포넌트-vs-class-컴포넌트-상태관리-주의\">☠️ 함수형 컴포넌트 vs class 컴포넌트 상태관리 주의<\/h1><p>아주 기본적이면서도 때때로 이런 기본적인 것들을 망각할 때가 많다. \n반성하면서 포스팅을 한다.<\/p><pre><code class=\"language-javascript\">[함수형 컴포넌트 (hook: useState)]\n\nimport React, { useState } from &#39;react&#39;\n\nconst [emailPw, setEmailPw] = useState({email: &quot;&quot;, password: &quot;&quot;})\n    const hadleInputValue = (key) =&gt; (text) =&gt; {\n        setEmailPw({\n            ...emailPw, // !!!\n            [key]: text.target.value,\n        });\n    };\n  ...생략...\n  &lt;div&gt;\n    &lt;input\n        type=&quot;email&quot;\n        onChange={hadleInputValue(&quot;email&quot;)}\n    &gt;&lt;/input&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;input\n        type=&quot;password&quot;\n        onChange={hadleInputValue(&quot;password&quot;)}\n    &gt;&lt;/input&gt;\n  &lt;/div&gt;\n\n\n\n[class형 컴포넌트 (setState)]\n  ...생략...\n  this.state = {\n      email: &quot;&quot;,\n      password: &quot;&quot;\n  }\n  ...생략...\n\n  hadleInputValue = (key) =&gt; (text) =&gt; {\n      this.setState({\n          [key]: text.target.value,\n       });\n  };\n...생략...\n  &lt;div&gt;\n    &lt;input\n        type=&quot;email&quot;\n        onChange={hadleInputValue(&quot;email&quot;)}\n    &gt;&lt;/input&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;input\n        type=&quot;password&quot;\n        onChange={hadleInputValue(&quot;password&quot;)}\n    &gt;&lt;/input&gt;\n  &lt;/div&gt;<\/code><\/pre><p>클래스형 컴포넌트에서는 setState를 하면 기존 값에 이어 state객체 안에 보존되지만,\n함수형 컴포넌트에서는 이전 상탯값 상태값을 지워버린다.\n기존 코드를 타입스크립트로 리팩토링하면서 이러한 함정에 많이 헤맸다.(예시 코드는 타입스크립트 X) \n이러한 차이점을 염두하여 함수형 컴포넌트의 기존 상태값이 지워지지 않도록\n<code>...state<\/code>와 같이 <strong>Spread 연산자<\/strong>를 이용하여 불변성을 유지하자.<\/p>"
      },
      {
        "title": "[CSS] box-sizing: border-box",
        "link": "https://velog.io/@potter/CSS-box-sizing-border-box",
        "guid": "https://velog.io/@potter/CSS-box-sizing-border-box",
        "pubDate": "Sat, 16 Jan 2021 09:45:10 GMT",
        "description": "<p>margin, padding, border값이 각기 다른 박스들의 크기를 동일하게 만드는 것은 여간 어려운 것이 아니다. 하지만 통일성 있는 박스들의 크기 조정을 위해 box-sizing이라는 CSS코드가 존재하니 간단하게 살펴보겠다.<\/p><h1 id=\"box-sizing\">box-sizing<\/h1><p>box-sizing이란 테두리 경계의 크기가 동일하게 만들어 박스의 크기가 좀 더 예측가능하기 쉽게하고 이해하기 쉽게 만든다고 한다.<\/p><p>초기 CSS는 각 박스들의 크기를 엘리먼트의 <code>컨텐츠의 크기<\/code>에 맞춰 조정하였다. 그럼 여기서 두 개의 박스가 있다고 가정했을 때 동일하게 <strong>150px<\/strong>로 크기를 지정하고, 테두리의 border값만 다르게 적용해보겠다. \n<img src=\"https://images.velog.io/images/potter/post/81291568-3e9c-4198-ad37-bbc373489eb3/image.png\" alt=\"\"><\/p><h5 id=\"기본-설정box-sizing-content-box\">(기본 설정==box-sizing: content-box)<\/h5><p>위의 사진에서 볼 수 있듯이 하얀색 부분의 컨텐츠의 크기는 150px로 동일하지만 테두리의 크기의 영향을 받아 박스 전체의 크기를 컨트롤하기가 어려워졌다. <\/p><p>테두리의 padding, margin, border을 미세조정하면서 두개의 박스의 크기를 맞추는 번거로움이 생겼다.<\/p><h3 id=\"box-sizing-border-box\">box-sizing: border-box;<\/h3><p>여기서 <code>box-sizing<\/code>의 속성 중 <code>border-box<\/code>로 설정해보면 아래 사진과 같이 나온다.\n<img src=\"https://images.velog.io/images/potter/post/aab9430e-98d7-48af-97c6-788eec7a95c2/image.png\" alt=\"\"><\/p><p>contents의 크기는 달라졌지만 border 경계의 크기를 기준으로 박스들의 크기가 통일이 되었다. <\/p><pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;style&gt;\n    /* 아스틱 태그: &quot;*&quot; ==&gt; 웹에 등장하는 모든 태그라는 선택자. */\n    * {\n      box-sizing: border-box;\n    }\n\n    div {\n      margin: 10px;\n    }\n\n    #small {\n      border: 10px solid black;\n      /* padding: 20px; */\n      width: 150px;\n    }\n\n    #large {\n      border: 30px solid black;\n      /* padding: 50px; */\n      width: 150px;\n    }\n  &lt;/style&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;small&quot;&gt;Hello world&lt;/div&gt;\n  &lt;div id=&quot;large&quot;&gt;Hello world&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;<\/code><\/pre><p>물론 여기서 padding값을 주면 크기가 또 달라진다. \n하지만 크기 기준이 contents가 아닌 border로 맞춰지기에 크기 변화의 예상이 더 수월하다고 한다. <\/p>"
      },
      {
        "title": "[CSS] flex",
        "link": "https://velog.io/@potter/CSS-flex",
        "guid": "https://velog.io/@potter/CSS-flex",
        "pubDate": "Mon, 11 Jan 2021 05:05:35 GMT",
        "description": "<p>레이아웃을 잡을 때 널리 활용되는 flex라는 녀석을 다뤄볼까 한다.<\/p><h2 id=\"속성\">속성<\/h2><p>flex는 정렬하고자 하는 각각의 item들은 container역할을 해주는 부모 태그가 필요하다. 또한 여러가지 속성들이 있고 속성별로 부모태그 혹은 자식태그에 위치할 곳도 다르다.<\/p><pre><code class=\"language-javascript\">&lt;container&gt;\n  &lt;item&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;/item&gt;\n&lt;/container&gt;<\/code><\/pre><p>부모코드: <code>&lt;container&gt;<\/code>\n자식코드: <code>&lt;item&gt;<\/code>\n라고 정의를 할 때,<\/p><pre><code class=\"language-javascript\">// 부모태그 컨테이너\n&lt;container /&gt;\n  display\n  flex-direction\n  flex-wrap\n  flex-flow\n  justify-content\n  align-items\n  align-content\n\n// 자식태그 정렬대상\n&lt;item /&gt;\n  order\n  flex-grow\n  flex-shrink\n  flex-basis\n  flex\n  align-self\n<\/code><\/pre><p>참.. 프로젝트하면서 애를 먹였던 부분이 위의 코드 내용이다. \n어떤 부분에 어떤 속성을 적용해야하는지 매번 헷갈리는 것 같다. <\/p><h2 id=\"flex-grow\">flex-grow<\/h2><p>생활코딩에서 제공한 코드로 작성해봤으며, 아래 코드를 토대로 포스트를 이어나가보겠습니다.<\/p><pre><code class=\"language-javascript\">&lt;!doctype&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;style&gt;\n        .container{\n            background-color: powderblue;\n            height:200px;\n            display:flex;\n            flex-direction:row;\n        }\n        .item{\n            background-color: tomato;\n            color:white;\n            border:1px solid white;         \n        }\n\n        .item:nth-child(2){\n\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;\n        &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;\n        &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;\n        &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;\n        &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/code><\/pre><ul><li><p>flex-grow: 부모컨네이너의 여백을 자식태그들이 n빵하여 나눠가지게 한다.<\/p><ul><li>주의 <ul><li><code>flex-grow(0): 설정값이 0이기에 아무런 변화 X<\/code><\/li><li><code>flex-grow(1): 아래와 같이 변화<\/code><\/li><\/ul><\/li><\/ul><p><img src=\"https://images.velog.io/images/potter/post/15527d79-4fcf-4c0c-86e0-b323ff39b67a/image.png\" alt=\"\"><\/p><p><img src=\"https://images.velog.io/images/potter/post/249cb4af-acae-44e1-9ec5-60c52b3ab69b/image.png\" alt=\"\"><\/p><\/li><\/ul><p>만약 여기서 특정 아이템의 크기를 조정하고 싶다면,<\/p><pre><code class=\"language-javascript\">.item:nth-child(2)\n  flex-grow:2;<\/code><\/pre><p>  나머지 아이템들의 grow는 1인 상태고, 두번째 아이템만 2인 상태이다.\n  2를 가져간 아이템만 차지하는 공간이 더 커짐을 알 수 있다. 3,4++하면 차지하는 공간이 더 커진다.\n  <img src=\"https://images.velog.io/images/potter/post/d4badb6e-57f0-4c33-ab02-77d2e0d8b213/image.png\" alt=\"\"><\/p><h2 id=\"flex-shrink\">flex-shrink<\/h2><p>flex-basis의 값을 가지고 있을 때, basis의 값을 줄인다. <\/p><pre><code class=\"language-javascript\">.item:nth-child(2)\n  flex-grow:2;<\/code><\/pre><ul><li><code>flex-shrink: 0<\/code> : 크기 변화 없음<\/li><li><code>flex-shrink: 1<\/code> : 크기 줄어든다<\/li><li><code>flex-shrink: 2<\/code> : 크기 변화 1보다 빠르게 줄어든다. 3, 4도 마찬가지.<h2 id=\"전체코드\">전체코드<\/h2><pre><code class=\"language-javascript\">&lt;!doctype&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;style&gt;\n      .container{\n          background-color: powderblue;\n          height:200px;\n          display:flex;\n          flex-direction:row;\n      }\n      .item{\n          background-color: tomato;\n          color:white;\n          border:1px solid white;         \n      }\n      .item:nth-child(1){\n          flex-basis: 150px;\n          flex-shrink: 1;\n      }\n      .item:nth-child(2){\n          flex-basis: 150px;\n          flex-shrink: 2;\n      }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;container&quot;&gt;\n      &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;\n      &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;\n      &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;\n      &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;\n      &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/code><\/pre><\/li><\/ul><h4 id=\"기타-속성\">기타 속성<\/h4><ul><li><a href=\"https://opentutorials.org/course/2418/13526\">holy grail layout<\/a><\/li><li><a href=\"https://youtu.be/8DJBCHro-3Q\">기타<\/a><\/li><\/ul>"
      },
      {
        "title": "반응형 - media query[1]",
        "link": "https://velog.io/@potter/%EB%B0%98%EC%9D%91%ED%98%95-media-query1",
        "guid": "https://velog.io/@potter/%EB%B0%98%EC%9D%91%ED%98%95-media-query1",
        "pubDate": "Mon, 11 Jan 2021 02:23:06 GMT",
        "description": "<p>오늘 날, 사회가 발전할 수록 컴퓨터, 태블릿, 휴대폰, 키오스크 등 아주 다양한 형태의 미디어 장치들이 존재한다. 각 장치마다 화면의 크기가 다를텐데 이 크기 혹은 이 장치에 적합한 화면을 출력, 적합한 표현을 할 수 있도록 해주는 것이 Media query이다.\n즉, 화면의 크기에 능동적으로 디자인이 반응하여 최적화된 모습을 보여주는 것이 반응형 디자인이라고 하는데, 이 반응형 디자인의 핵심이 바로 Media query라고 한다. <\/p><h3 id=\"예제-코드\">예제 코드<\/h3><p>화면 크기가 <strong>최대 500px<\/strong>일 때 backgound-color -&gt; yellow로 변환되게 설정해보았다.<\/p><pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;\n\n  &lt;style&gt;\n    @media (max-width: 500px) {\n      body {\n        background-color: yellow;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/fa26af01-363a-42fb-a5fc-8cb797ed609d/%E1%84%87%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%92%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A8%E1%84%8C%E1%85%A6.gif\" alt=\"\"><\/p><p>max-width: 최대 사이즈\nmin-width: 최소 사이즈<\/p><h2 id=\"우선-순위순서\">우선 순위(순서)<\/h2><p>만약 500px이하 yellow, 501px~600px까지 red로 설정하고 싶을 때, 아래와 같이 @media를 두 번 작성해주면 된다.<\/p><pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;\n\n  &lt;style&gt;\n    @media (max-width: 600px) {\n      body {\n        background-color: red;\n      }\n    }\n    @media (max-width: 500px) {\n      body {\n        background-color: yellow;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/30a34768-65d7-4961-97f3-421262444c90/%E1%84%87%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%92%E1%85%A7%E1%86%BCred,yellow.gif\" alt=\"\"><\/p><p><strong>여기서 중요한 것은<\/strong> @media의 순서이다. 하나의 태그 안에서 <strong>같은<\/strong> 효과를 적용하고자 할 때 과연 어떤 이벤트에 우선순위를 정해주어야하는지(캐스캐이딩)가 문제가 되는데, 결국 우선순위가 주어지는 코드는 나중에 나오는 코드가 높은 우선순위를 가지게 된다. \n위의 코드를 살펴보면 @media 안에 있는 body태그가 같은 <strong>max<\/strong>-width로 yellow와 red의 효과를 적용해야만 한다. <\/p><p>만약 위의 코드와 다른 순서로 아래 코드와 같이 작성한다면, 600px 이하 = red 효과가 우선순위를 가지게 될 것이고, 결국 600px 이하의 모든 사이즈들은 몽땅 red로 적용이 될 것이다. <\/p><pre><code class=\"language-javascript\">    @media (max-width: 500px) {\n      body {\n        background-color: yellow;\n      }\n    }\n\n    @media (max-width: 600px) {\n      body {\n        background-color: red;\n      }\n    }<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/55ffbe28-b0af-4ba7-9685-4afc2f23d2a5/%E1%84%87%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%92%E1%85%A7%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%86%E1%85%A9%E1%86%BA%E1%84%83%E1%85%AC%E1%86%AB%20%E1%84%89%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5.gif\" alt=\"\"><\/p><p>순서에 유의하도록 하자!<\/p><p>참고: 생활코딩<\/p>"
      },
      {
        "title": "redux-toolkit 리팩토링 4 - createSlice",
        "link": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4-createSlice",
        "guid": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4-createSlice",
        "pubDate": "Fri, 08 Jan 2021 12:13:24 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/f54d5dfe-7a16-4fc6-858a-fc29b460cc9c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-08%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.37.34.png\" alt=\"\">\n간단한 To-Do를 구현하면서 리덕스 공부를 해보았고, \n이 포스트에서도 역시 To Do를 간단하게 완성한 후 redex에서 제공하는 tookit을 적용해 코드를 더욱 더 간결하게 리팩토링을 해보도록 하겠다. <\/p><p>지난 createAction 포스트에서 작성했던 동일한 서론으로 시작해보겠다.<\/p><h2 id=\"why-toolkit\">why toolkit?<\/h2><p>Redux를 사용하다보면 action creator 혹은 Boilerplate Code와 같이 반복되는 코드를 작성하는 등, 코드가 길어지는 경우가 많다. 이에 많은 개발자분들이 불편함을 느끼게 되었고, 그로 인해 Redux-toolkit이 탄생하게 되었다. <\/p><p><strong>redux-toolkit 이란?<\/strong>\n보다 효율적인 코드작성을 위한 package라고 보면 된다.\n더 적은 양의 코드로 toolkit 적용 전의 코드와 같은 기능을 하도록 도와주는 것으로 보자.<\/p><p>[종류]<\/p><ol><li><a href=\"https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0\">createAction<\/a><\/li><li><a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-createReducer\">createReducer<\/a><\/li><li><a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3-configureStore\">configureStore<\/a><\/li><\/ol><p><strong>4. createSlice<\/strong>\n(클릭하시면 해당 포스트로 이동합니다.)<\/p><p>이 포스트에서는 <strong>4. createSlice<\/strong>의 내용을 다루도록 하겠다. <\/p><h2 id=\"설치\">설치<\/h2><pre><code class=\"language-javascript\">  yarn add @reduxjs/toolkit<\/code><\/pre><h2 id=\"createslice\">createSlice<\/h2><p>createSlice 함수는 앞서 리팩토링했던 코드들의 라인을 줄여주는 역할을 한다고 한다. \n또한, createSlice 함수는 reducer뿐 만 아니라 action까지 생성해준다.\n한마디로 action, reducer을 캡슐화한 버전이 createSlice인 것이다.<\/p><p><strong>적용 전<\/strong><\/p><pre><code class=\"language-javascript\">const addToDo = createAction(&quot;ADD&quot;)  \nconst deleteToDo = createAction(&quot;DELETE&quot;)\n\nconst reducer = createReducer([], {\n  [addToDo]: (state, action) =&gt; {  \n    state.push({ text: action.payload, id: Date.now() });   },                                                     \n  [deleteToDo]: (state, action) =&gt;  // 리턴 O \n    state.filter(toDo =&gt; toDo.id !== action.payload)\n})\n\nconst store = configureStore({ reducer })\n\nexport const actionCreators = {\n  addToDo,\n  deleteToDo\n}<\/code><\/pre><p><strong>적용 후<\/strong>\ncreateSlice는 몇가지 옵션을 받는다<\/p><ul><li>name  <\/li><li>initialState  <\/li><li>reducers(action creater를 만들기보다는 action을 직접 넣어보겠음.)<\/li><\/ul><pre><code class=\"language-javascript\">const toDos = createSlice({\n  name: &quot;toDoReducer&quot;,\n  initialState: [].\n  reducers: {    // addToDo의 명칭 중복 방지를 위해 add로 정정\n    add: (state, action) =&gt; {\n      state.push({ text: action.payload, id: Date.now() });\n    },\n    remove: (state, action) =&gt;  // 명칭 중복 방지를 위해 deleteTodo =&gt; remove로 정정\n    state.filter(toDo =&gt; toDo.id !== action.payload)\n  }\n})\n// createSlice는 action, reducer기능 모두 가능함. \n// 따라서 아래처럼 console.log()로 확인해보면 actions, caseReducers, reducer가 담긴 것을 확인할 수 있다.\nconsole.log(toDos);\n// reducer함수를 삭제하고 createSlice로 대체했으니 toDos의 reducer를 가져와 store의 reducer를 다시 설정해줘야 한다.\nconst store = configureStore({ reducer: toDos.reducer });\n\n// actionCreator를 createSlice로 대체했으니 알맞게 아래와 같이 변경. \n// 따라서 Home.js &amp; ToDo.js도 수정해줘야 함.\nexport const { add, remove } = toDos.actions;\n\nexport default store;<\/code><\/pre><h2 id=\"마치며\">마치며<\/h2><p>createAction, createReducer 모두 같은 기능을 하면서 코드줄 수를 혁신적으로 줄이게 하는 것이 경이로웠다. 하지만 createSlice는 위의 두개를 모두 캡슐화(포함)하면서 코드가 더 줄어들게 만들고 있다.. 아.. 여지껏 redux 공부를 소홀히 하였던 내가 정말 한심해보여지는 순간이다..\n물론 리덕스 없이 파이널 프로젝트를 해내서 그런지 리액트에 대한 자신감이 높아졌지만! 이제는 redux와 react의 적절한 조화를 이루면서 프로젝트를 진행해야겠다. <\/p><p>이력서를 열심히 작성하고 열심히 구직 중이지만, 여간 힘든게 아니다. \n부트캠프를 무사히 수료했지만 끝난게 끝난 것이 아닌.. 새로운 시작인거다!!<\/p><p>프론트엔드 웹 개발자 이재훈 파이팅!! <\/p>"
      },
      {
        "title": "redux-toolkit 리팩토링 3 - configureStore",
        "link": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3-configureStore",
        "guid": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3-configureStore",
        "pubDate": "Fri, 08 Jan 2021 09:50:48 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/daa7c8e1-dc08-4a11-b362-d79209e54a94/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-08%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.37.34.png\" alt=\"\"><\/p><p>간단한 To-Do를 구현하면서 리덕스 공부를 해보았고, \n이 포스트에서도 역시 To Do를 간단하게 완성한 후 redux에서 제공하는 tookit을 적용해 코드를 더욱 더 간결하게 리팩토링을 해보도록 하겠다. <\/p><p>지난 createAction 포스트에서 작성했던 동일한 서론으로 시작해보겠다.<\/p><h2 id=\"why-toolkit\">why toolkit?<\/h2><p>Redux를 사용하다보면 action creator 혹은 Boilerplate Code와 같이 반복되는 코드를 작성하는 등, 코드가 길어지는 경우가 많다. 이에 많은 개발자분들이 불편함을 느끼게 되었고, 그로 인해 Redux-toolkit이 탄생하게 되었다. <\/p><p><strong>redux-toolkit 이란?<\/strong>\n보다 효율적인 코드작성을 위한 package라고 보면 된다.\n더 적은 양의 코드로 toolkit 적용 전의 코드와 같은 기능을 하도록 도와주는 것으로 보자.<\/p><p>[종류]<\/p><ol><li><a href=\"https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0\">createAction<\/a><\/li><li><a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-createReducer\">createReducer<\/a><\/li><\/ol><p><strong>3. configureStore<\/strong>\n4. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4-createSlice\">createSlice<\/a>\n(클릭하시면 해당 포스트로 이동합니다.)<\/p><p>이 포스트에서는 <strong>3. configureStore<\/strong>의 내용을 다루도록 하겠다. <\/p><h2 id=\"설치\">설치<\/h2><p>사실, configuresStore함수는 Redux Developer Tools를 사용하기 위한 function이라서 별도로 Redux-toolkit을 설치할 필요가 없다. <\/p><h2 id=\"configurestore\">configureStore<\/h2><p>createStore 기능을 하는 동시에 Redux Devolper Tools 기능을 수행 할 수 있는 함수이다.<\/p><p>적용 전<\/p><pre><code class=\"language-javascript\">const store = createStore(reducer);<\/code><\/pre><p>적용 후<\/p><pre><code class=\"language-javascript\">const store = configureStore({ reducer });<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/9fcc8aff-baf0-4566-9708-dd29fc0258cb/image.png\" alt=\"\"><\/p><h2 id=\"redux-developer-tools\">Redux Developer Tools<\/h2><p>redux를 사용하여 개발을 하였다면 state에 어떤 일이 발생했는지 정확하게 알 수 있다고 한다. 이 외에도 여러 변화에 따른 상태를 추적할 수 있다고 한다. 자세한 사용법은 노션에 정리해놨으니 살펴보기!<\/p>"
      },
      {
        "title": "redux-toolkit 리팩토링 2 - createReducer",
        "link": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-createReducer",
        "guid": "https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-createReducer",
        "pubDate": "Fri, 08 Jan 2021 07:38:52 GMT",
        "description": "<p>간단한 To-Do를 구현하면서 리덕스 공부를 해보았고, \n이 포스트에서도 역시 To Do를 간단하게 완성한 후 redex에서 제공하는 tookit을 적용해 코드를 더욱 더 간결하게 리팩토링을 해보도록 하겠다. <\/p><p>지난 createAction 포스트에서 작성했던 동일한 서론으로 시작해보겠다.<\/p><h2 id=\"why-toolkit\">why toolkit?<\/h2><p>Redux를 사용하다보면 action creator 혹은 Boilerplate Code와 같이 반복되는 코드를 작성하는 등, 코드가 길어지는 경우가 많다. 이에 많은 개발자분들이 불편함을 느끼게 되었고, 그로 인해 Redux-toolkit이 탄생하게 되었다. <\/p><p><strong>redux-toolkit 이란?<\/strong>\n보다 효율적인 코드작성을 위한 package라고 보면 된다.\n더 적은 양의 코드로 toolkit 적용 전의 코드와 같은 기능을 하도록 도와주는 것으로 보자.<\/p><p>[종류]<\/p><ol><li><a href=\"https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0\">createAction<\/a><\/li><\/ol><p><strong>2. createReducer<\/strong>\n3. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3-configureStore\">configureStore<\/a>\n4. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4-createSlice\">createSlice<\/a>\n(클릭하시면 해당 포스트로 이동합니다.)<\/p><p>이 포스트에서는 <strong>2. createReducer<\/strong>의 내용을 다루도록 하겠다. <\/p><h2 id=\"설치\">설치<\/h2><pre><code class=\"language-javascript\">  yarn add @reduxjs/toolkit<\/code><\/pre><h2 id=\"createreducer\">createReducer<\/h2><p>reducer란\n기본 state를 action을 통해 새로운 state로 변형시키고, 그 값을 store에 전달한다.<\/p><p>기본 Redux의 reducer 함수가 어떻게 toolkit으로 재탄생이 되는지 아래에서 살펴보겠다.\n<strong><em><a href=\"https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0\">createAction<\/a>에서 리팩토링한 코드에 연장선이니 해당 포스트를 참고바랍니다.<\/em><\/strong><\/p><p><strong>createReducer 적용 전<\/strong><\/p><pre><code class=\"language-javascript\">const reducer = (state = [], action) =&gt; {\n  switch (action.type) {\n    case addToDo.type: // string\n      return [{ text: action.payload, id: Date.now() }, ...state];\n    case deleteToDo.type:\n      console.log(action)\n      return state.filter(toDo =&gt; toDo.id !== action.payload);\n    default:\n      return state;\n  }\n};<\/code><\/pre><p><strong>createReducer 적용 후<\/strong><\/p><ol><li><p>state를 mutate하기 쉽게 만들어준다. (기존 reducers는 mutate를 하지 못했다.새로운 state를 만들어야 했다.) 즉, 배열에 push를 하여 기존 배열의 값을 변형시킬 수 있게 해준다.<\/p><\/li><li><p>state의 mutate 유무에 따른 return 여부<\/p><ul><li>mutate를 했다면 return X<\/li><li>mutate를 하지 않았다면 return O  <\/li><\/ul><\/li><li><p>더이상 switch가 필요하지않으나 위의 reducer함수와 정확하게 동일한 기능을 한다.<\/p><\/li><li><p>createReducer(intial_state, 타입에 따른 action 실행 조건을 담은 객체)<\/p><pre><code class=\"language-javascript\">const reducer = createReducer([], {\n// action이 addToDo일 때 파라미터에 state와 action을 넘기고, {}안에서 무엇인가를 하게 할 것임. 기존 reducer와 같이 &quot;type이 무엇일 때 어떤걸 한다&quot; 와 동일\n[addToDo]: (state, action) =&gt; {  // 리턴 X : redux의 reducer에서 return을 하려면 반드시 새로운 state를 return해야한다. 따라서 내가 변형한 값을 리턴하지 말아야하는 주의가 필요하다. \n state.push({ text: action.payload, id: Date.now() });  // 그렇다면 어떻게 여기선 mutate가 가능한것일까? redux-toolkit이 immer 안에서 작동해서 그렇다는데, 여기서 우리가 변형을 했다하여도, 여기서 toolkit과 immer가 이 정보만 가져가는 것일 뿐이고 그 후에 위에서 내가 기본 reducer에서 새로운 state를 만들었던 것처럼 toolkit과 immer가 대신 해준다. 결국 여기서 내가 push로 state를 변형시키지만 결국 새로운 state가 되는 것.\n},                                                       // 따라서, mutate를 했다면 절대 return 하지 말것. 하면 오류남.\n[deleteToDo]: (state, action) =&gt;  // 리턴 O \n state.filter(toDo =&gt; toDo.id !== action.payload)\n})<\/code><\/pre><\/li><\/ol><h2 id=\"정리\">정리<\/h2><p>여기서 중요한 포인트는 아래와 같을 것 같다.<\/p><ol><li>switch 구문을 사용하지 않아도 된다.<\/li><li>Redux의 reducer에서 state를 변형시키면 안된다!!<ul><li>state를 변형시키는 코드를 작성 시 return 금지!\n(toolkit &amp; immer가 새로운 state를 리턴하게 해줄 것이다. 더 상세한 이유는 아직 잘 모르겠다.)<\/li><li>state를 변형시키지 않았다면 바로 return 가능!<\/li><\/ul><\/li><\/ol>"
      },
      {
        "title": "redux-toolkit 리팩토링 1 - createAction",
        "link": "https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0",
        "guid": "https://velog.io/@potter/redux-toolkit%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EB%B3%B4%EA%B8%B0",
        "pubDate": "Thu, 07 Jan 2021 08:29:35 GMT",
        "description": "<p>간단한 To-Do를 구현하면서 리덕스 공부를 해보았고, \nTo Do를 간단하게 완성한 후 redex에서 제공하는 tookit을 적용해 코드를 더욱 더 간결하게 리팩토링을 해보도록 하겠다. <\/p><h2 id=\"why-toolkit\">why toolkit?<\/h2><p>Redux를 사용하다보면 action creator 혹은 Boilerplate Code와 같이 반복되는 코드를 작성하는 등, 코드가 길어지는 경우가 많다. 이에 많은 개발자분들이 불편함을 느끼게 되었고, 그로 인해 Redux-toolkit이 탄생하게 되었다. <\/p><p><strong>redux-toolkit 이란?<\/strong>\n보다 효율적인 코드작성을 위한 package라고 보면 된다.\n더 적은 양의 코드로 toolkit 적용 전의 코드와 같은 기능을 하도록 도와주는 것으로 보자.<\/p><p>[종류]\n<strong>1. createAction<\/strong>\n2. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-createReducer\">createReducer<\/a>\n3. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-3-configureStore\">configureStore<\/a>\n4. <a href=\"https://velog.io/@potter/redux-toolkit-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-4-createSlice\">createSlice<\/a>\n(클릭하시면 해당 포스트로 이동합니다.)<\/p><p>이 포스트에서는 <strong>1. createAction<\/strong>의 내용을 다루도록 하겠다. <\/p><h2 id=\"설치\">설치<\/h2><pre><code class=\"language-javascript\">  yarn add @reduxjs/toolkit<\/code><\/pre><h2 id=\"createaction\">createAction<\/h2><p>아래와 같이 action creator 함수를 작성하는 대신에 createAction이라는 코드를 작성해 코드를 줄여볼 것이다.<\/p><p>createAction 적용 전<\/p><pre><code class=\"language-javascript\">const ADD = &quot;ADD&quot;;\nconst DELETE = &quot;DELETE&quot;;\n\n\n// action creator\nconst addToDo = text =&gt; {\n  return {\n    type: ADD,\n    text\n  };\n};\nconst deleteToDo = id =&gt; {\n  return {\n    type: DELETE,\n    id\n  };\n}; <\/code><\/pre><p>createAction 적용 후<\/p><pre><code class=\"language-javascript\">import { createAction } from &quot;@reduxjs/toolkit&quot;;\n\nconst addToDo = createAction(&quot;ADD&quot;);\nconst deleteToDo = createAction(&quot;DELETE&quot;); \n\n// 여기서 단 2개의 줄로 코드 완성. \n// 단 type을 ADD로 선언한 것을 지웠기 때문에 아래 reducer함수의 case부분은 아래와 같이 변경할 것!\n\n\nconst reducer = (state = [], action) =&gt; {\n  switch (action.type) {\n    // case ADD:\n    case addToDo.type:\n      return [{ text: action.text, id: Date.now() }, ...state];\n    // case DELETE:\n    case deleteToDo.type:\n      return state.filter(toDo =&gt; toDo.id !== action.id);\n    default:\n      return state;\n  }\n};\n\n참고\nconst addToDo = createAction(&quot;ADD&quot;); ---&gt; 함수\ncase addToDo.type  ---&gt; string\n\n이 차이점을 알아두기.\n\n또한 addToDo()는 payload를 항상 같이 보낸다.\n(아래 캡쳐사진 보기.)<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/6801db70-e9ed-4b11-af1b-fe04506544e6/image.png\" alt=\"\"><\/p><h2 id=\"payload\">payload<\/h2><p><img src=\"https://images.velog.io/images/potter/post/3f322c22-1ebc-49f4-b1a3-a1e07613d087/image.png\" alt=\"\">\n위의 사진과 같이  input칸에 어떠한 값을 입력해도 출력되는 list는 공백으로 나온다. <\/p><pre><code class=\"language-javascript\">console.log(addToDo) // {type: &quot;ADD&quot;, payload: undefined}<\/code><\/pre><p>이는 createAction을 사용함으로써 리팩토링한 addToDo함수가 payload를 같이 보내고 있지만, 위의 콘솔로그처럼 text(input값)에 대한 값을 가지고 있지 않다. 단지 type &amp; payload만 가지고 있을 뿐이다.<\/p><p>createAction 파트에서 작성한 코드 중 reducer 함수를 살펴보면 내가 출력하고자 할 todo-list 부분을<\/p><pre><code class=\"language-javascript\">      case addToDo.type:\n      return [{ text: action.text, id: Date.now() }, ...state];<\/code><\/pre><p>이처럼 구현했는데, createAction의 addToDo함수는 text를 가지고 있지않다는 뜻이다.<\/p><p><strong>하.지.만<\/strong>\n다행이도, redux-tookit은 어떤 정보를 출력하든지 혹은 전송하든지간에 payload에 담겨 함께 보내진다. 따라서 위의 코드를 아래와 같이 리팩토링하면 된다. <\/p><p>(input칸에 &quot;payload로 변경 후&quot;라고 입력하였다고 가정)<\/p><pre><code class=\"language-javascript\">...생략\n return [{ text: action.payload, id: Date.now() }, \n...생략\n\nconsole.log(action) // {type: &quot;ADD&quot;, payload: &quot;payload로 변경 후&quot;}<\/code><\/pre><p>&quot;text&quot; -&gt; &quot;payload&quot;로 변경만 하면 끝!<\/p><p>자, 그럼 아래 사진으로 결과물을 확인하고 포스팅을 마치도록 하겠다!\n<img src=\"https://images.velog.io/images/potter/post/5bfb57e0-671b-481d-8163-5b84aa5acd05/chrome-capture.gif\" alt=\"\"><\/p><p><strong>정리<\/strong>\n더이상 action을 정의하지 않아도 된다는 것! GOOD!<\/p>"
      },
      {
        "title": "[알고리즘] isSubsetOf",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-isSubsetOf",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-isSubsetOf",
        "pubDate": "Tue, 29 Dec 2020 14:49:42 GMT",
        "description": "<h2 id=\"문제\">문제<\/h2><p>두 개의 배열(<code>base<\/code>, <code>sample<\/code>)을 입력받아 <code>sample<\/code>이 <code>base<\/code>의 부분집합인지 여부를 리턴해야 합니다.<\/p><ul><li><code>boolean<\/code> 타입을 리턴해야 합니다.<\/li><\/ul><h2 id=\"입출력-예시\">입출력 예시<\/h2><pre><code class=\"language-javascript\">let base = [1, 2, 3, 4, 5];\nlet sample = [1, 3];\nlet output = isSubsetOf(base, sample);\nconsole.log(output); // --&gt; true\n\nsample = [6, 7];\noutput = isSubsetOf(base, sample);\nconsole.log(output); // --&gt; false\n\nbase = [10, 99, 123, 7];\nsample = [11, 100, 99, 123];\noutput = isSubsetOf(base, sample);\nconsole.log(output); // --&gt; false\n\n\n** Advanced\n\n- 시간 복잡도를 개선하여, Advanced 테스트 케이스(`base`, `sample`의 길이가 70,000 이상)를 통과해 보세요.<\/code><\/pre><h2 id=\"풀이\">풀이<\/h2><h3 id=\"첫번째-시도---advanced-실패\">첫번째 시도 - Advanced 실패<\/h3><p>그냥 요로코롬 풀면 되겠지 했지만, 따아악 1개만 실패하고 모두 통과했다.\nAdvanced는 총 3개의 테스트케이스가 나왔고, 그 중 1개가 실패한 것이다.<\/p><pre><code class=\"language-javascript\">const isSubsetOf = function (base, sample) {\n  // TODO: 여기에 코드를 작성합니다.\n  for(let item of sample) {\n    if(base.includes(item)) {\n      return true;\n    }\n      return false;\n  }\n};<\/code><\/pre><h3 id=\"두번째-시도---동일하게-실패\">두번째 시도 - 동일하게 실패<\/h3><p>위와 동일한 테스트 케이스의 문턱을 넘지 못했다. \n다시 돌아보니 달라질게 없는 코드이긴 하다.<\/p><pre><code class=\"language-javascript\">const isSubsetOf = function (base, sample) {\n  // TODO: 여기에 코드를 작성합니다.\n  set1 = new Set(base);\n  for(let item of sample) {\n    return set1.has(item);\n  }\n};<\/code><\/pre><p><img src=\"https://images.velog.io/images/potter/post/5f1197f3-e619-4824-a41b-e20dc722227f/image.png\" alt=\"\"><\/p><p>...\n아무래도 시간을 더 투자해서 뚫어봐야겠다 이 테스트 케이스의 문턱을..\n라니스터 같은 녀석...<\/p><h3 id=\"참고----mdn\">참고  - MDN<\/h3><p>set : Set 객체는 자료형에 관계 없이 원시 값과 객체 참조 모두 유일한 값을 저장할 수 있다.\nhas(): 주어진 키를 가진 요소가 Map에 존재하는지를 반환한다. 불린값으로 출력<\/p>"
      },
      {
        "title": "[알고리즘] 피보나치(fibonacci)",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98fibonacci",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98fibonacci",
        "pubDate": "Tue, 29 Dec 2020 14:37:42 GMT",
        "description": "<h2 id=\"문제\">문제<\/h2><p>아래와 같이 정의된 피보나치 수열 중 n번째 항의 수를 리턴해야 합니다.<\/p><ul><li><p>0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1입니다. 그 다음 2번째 피보나치 수부터는 바로 직전의 두 피보나치 수의 합으로 정의합니다.<\/p><\/li><li><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...<\/p><\/li><li><p><strong>재귀함수를 이용해<\/strong> 구현해야 합니다.<\/p><\/li><li><p>반복문(<code>for<\/code>, <code>while<\/code>) 사용은 금지됩니다.<\/p><\/li><\/ul><h2 id=\"입출력-예시\">입출력 예시<\/h2><pre><code class=\"language-javascript\">\nlet output = fibonacci(0);\nconsole.log(output); // --&gt; 0\n\noutput = fibonacci(1);\nconsole.log(output); // --&gt; 1\n\noutput = fibonacci(5);\nconsole.log(output); // --&gt; 5\n\noutput = fibonacci(9);\nconsole.log(output); // --&gt; 34\n\n\n** Advanced\n\n피보나치 수열을 구하는 효율적인 알고리즘(`O(N)`)이 존재합니다. 재귀함수의 호출을 직접 관찰하여 비효율이 있는지 확인해 보시기 바랍니다.\n<\/code><\/pre><h2 id=\"풀이\">풀이<\/h2><p>지난 알고리즘 가위바위보에서 사용했던 재귀 방식을 여기 이 알고리즘에게도 적용시켜 구현해보았다.\nrecursion의 파라미터에 count를 정의를 한 후 다시 재귀를 돌 때마다 바로바로 적용부터 한 후 재귀를 실행하게 하였다.<\/p><pre><code class=\"language-javascript\">\nfunction fibonacci(n) {\n  // TODO: 여기에 코드를 작성합니다.\n  let arr = [0, 1];\n\n  const recursion = (count = 2) =&gt; {\n    arr.push(arr[count-2] + arr[count-1]);\n\n    if(count === n) {\n      return;\n    }\n\n    recursion(count + 1);\n  }\n\n  if(n === 0) {\n    return 0;\n  }\n  else if(n === 1) {\n    return 1;\n  }\n  else {\n    recursion();\n    return arr[n];\n  }\n}\n<\/code><\/pre>"
      },
      {
        "title": "[알고리즘] 가위바위보(rockPaperScissors)",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%80%EC%9C%84%EB%B0%94%EC%9C%84%EB%B3%B4rockPaperScissors",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%80%EC%9C%84%EB%B0%94%EC%9C%84%EB%B3%B4rockPaperScissors",
        "pubDate": "Tue, 29 Dec 2020 14:25:06 GMT",
        "description": "<h2 id=\"문제\">문제<\/h2><p>가위바위보 게임은 2인 이상의 사람이 동시에 &#39;가위, 바위, 보&#39;를 외치고 동시에 가위, 바위 또는 보 중에서 한 가지를 의미하는 손 모양을 내밀어 승부를 결정짓는 게임이다. 세 판의 가위바위보 게임을 할 경우, 한 사람은 세 번의 선택(예. 가위, 가위, 보)을 할 수 있다. 세 번의 선택으로 가능한 모든 경우의 수를 구하는 함수를 작성한다.<\/p><h2 id=\"입출력-예시\">입출력 예시<\/h2><pre><code class=\"language-javascript\">\n  [\n    [&quot;rock&quot;, &quot;rock&quot;, &quot;rock&quot;],\n    [&quot;rock&quot;, &quot;rock&quot;, &quot;paper&quot;],\n    [&quot;rock&quot;, &quot;rock&quot;, &quot;scissors&quot;],\n    [&quot;rock&quot;, &quot;paper&quot;, &quot;rock&quot;],\n    // ...etc ...\n  ]\n\n\n** Advanced: 변수로 전달하는 판수에 맞는 정답을 return 하도록 작성한 함수를 바꿔 보세요.\n\n\nrockPaperScissors(5); // =&gt; [[&#39;rock&#39;, &#39;rock&#39;, &#39;rock&#39;, &#39;rock&#39;, &#39;rock&#39;], etc...]\n<\/code><\/pre><h2 id=\"풀이\">풀이<\/h2><ul><li>재귀<\/li><li>forEach()<\/li><\/ul><p>처음에는 for문으로 시작하여 구현하려고 했으나, 어디선가 코드가 꼬이는 바람에 다시 처음부터 시작하였다. \n이왕 뒤집어 엎은거 재귀로 돌려보기로 했다.\nrecursion의 파라미터에 count를 정의를 한 후 다시 재귀를 돌 때마다 바로바로 적용부터 한 후 재귀를 실행하게 하였다.<\/p><pre><code class=\"language-javascript\">\nconst rockPaperScissors = function(n) {\n  n = n || 3\n\n  let plays = [&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]\n  let res = [];\n\n  const recursion = (count = 0, nodeArr = []) =&gt; {  // for의 늪 대신 재귀 사용\n\n    if(count === round) {  // 종료조건  ---&gt; 1번째 판 ~~~5번째판 까지만 계산하면 된, 5판 땐, res에 담고 리턴, 재귀 종료\n\n     return res.push(nodeArr); \n    };\n\n      plays.forEach(item =&gt; {\n        let newNodeArr = [...nodeArr, item]  \n        recursion(count + 1, newNodeArr) \n      });\n\n  };\n  recursion();  \n  return res;\n\n};\n<\/code><\/pre>"
      },
      {
        "title": "[Final Project] 4주차 회고",
        "link": "https://velog.io/@potter/final-project-4%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0",
        "guid": "https://velog.io/@potter/final-project-4%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0",
        "pubDate": "Mon, 28 Dec 2020 00:48:42 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/d3ac9167-ca73-48fe-ad0c-41332f9f3930/image.png\" alt=\"\"><\/p><h1 id=\"✨-회고-및-팀원간-피드백\">✨ 회고 및 팀원간 피드백<\/h1><p>부트캠프에서 한 주를 마무리하면서 회고 및 팀원간 피드백을 권하여, 깃허브 issue에 각자 회고와 그 게시글의 댓글에 솔직한 피드백을 남겨주기로 했다. <\/p><h2 id=\"🌱-회고\">🌱 회고<\/h2><h3 id=\"fact-사실\">Fact (사실)<\/h3><ul><li>CSS 업데이트<\/li><\/ul><h3 id=\"feeling-느낌\">Feeling (느낌)<\/h3><ul><li>와..진짜 어렵다...<\/li><\/ul><h3 id=\"finding-교훈--사건에서-얻은-교훈을-적는다\">Finding (교훈) : 사건에서 얻은 교훈을 적는다<\/h3><ul><li>내 미적감각이 조선시대 수준이었단걸 깨달았다.<\/li><li>CSS라는 녀석은 파면팔수록 재미있긴하지만 언제까지 파야할지 모를정도로 그 깊이가 너무.. 기가 막히다..<\/li><\/ul><h3 id=\"future-action행동--그래서-내가-앞으로-취할-행동을-미래형으로-적는다\">Future action(행동) : 그래서 내가 앞으로 취할 행동을 미래형으로 적는다<\/h3><ul><li>요즘 트랜드에 따른 미적 감각과 더불어 CSS 훈련을 끊임없이 해야겠다.<\/li><\/ul><h2 id=\"🌱-피드백-from-팀원\">🌱 피드백 From 팀원<\/h2><p><strong>jswxxx<\/strong>\n일단 깊은 공감하나 하고 갑니닼ㅋㅋㅋㅋ CSS덕분인지, 리액트 덕분인지, 저는 절대 프론트개발자가 되지 않기로 결심했답니다^^\n내일 우리 같이 종일 CSS 건드릴 것 같은데 함께가시죠. 그러면 덜 힘들지 않을까요?ㅎㅎ<\/p><p><strong>JCxxx<\/strong>\n재훈님 미적감각이 조선시대라면 저는 뗀석기 시대일거 같습니다. 필요하시다면 고든 램지도 울고 갈 정도의 피드백 해드리겠습니다.<\/p><p><strong>latxxx<\/strong>\n빛 재훈이라고 부르겠습니다. 재훈님이 아니었다면 우리 프로젝트의 처음과 마지막을 모두 제대로 보지 못하게 되었을 것입니다. 몇번이나 말씀드리지만 재훈님께서 로그인과 세션관리를 완벽하게 구현해주신 덕분에 모든 테스트와 구현이 가능했습니다. 그리고 이어서 우리 서비스의 디자인 컨셉을 잡아주신 덕분에 신속한 프로젝트 마무리가 가능하게 될 것 같습니다. 남은 시간동안 CSS 앞잡이(x) 길잡이(o)가 되어주시어, 우리 모두가 멋진 서비스 화면을 만드는데 총력을 쏟게 해주십쇼!! ☺️<\/p><h2 id=\"🌱-final-project를-마치며\">🌱 Final Project를 마치며..<\/h2><p>4주 간의 대장정이 끝났다.\n이번 프로젝트를 통하여 리액트로 어떻게든 상태 관리를 완료했고, 그만큼 react와 더 친해졌을 것이다. 그리고.. 끝난게 끝난 것이 아니다. 이제는 리덕스, 타입스크립트 적용하면서 리팩토링에 들어가야한다. \nredux.. 아니나다를까.. 복잡해진 상태관리는 react만으로 한계가 있음을 느꼈다. 4주 동안 복잡성을 가진 상태관리에 엄청 두들겨맞았다. 상태 관리가 복잡성을 가지는 순간 효율적인 코드를 위해 존재하는 것이 redux임을 온 몸으로 느꼈다. 사실 일찍이 redux를 도입했다면 프로젝트의 퀄리티를 높이는데 더 시간을 쏟지 않았을까라는 생각이 든다. 이에 대한 느낀 점은 프로젝트를 끝낸 후 진행한 기술 발표에 &quot;redux 도입 필요성&quot; 주제를 담아보았다. 리덕스.. &quot;두드려 맞아봐야 안다&quot;라는 어머니의 가르침을 되새기며 4주간의 프로젝트 회고를 마치도록 하겠다.<\/p><p>이제 열심히 구직활동과 사이드 프로젝트에 집중해야 할 차례다. 늘어지지 말자. 파이팅!\n<br/><\/p><hr><br/>\n아래는 1-4주 회고를 한 곳으로 모아봤습니다.\n\n<h3 id=\"✨-지난-회고록-모음\">✨ 지난 회고록 모음<\/h3><h4 id=\"1-final-project---주제-선정\">1. [Final Project] - 주제 선정<\/h4><p>퍼스트 프로젝트가 끝난 후, 동일한 팀원들과 파이널 프로젝트에 돌입했다. \n우리는 지난 퍼스트 프로젝트를 기한 내에 완료하지 못한 아쉬움을 이번 파이널 프로젝트에서 달래기로 다짐한 후, 다시 zoom에서 만나 주제 선정을 시작하였다.<\/p><h4 id=\"프로젝트-주제-선정\">프로젝트 주제 선정<\/h4><h4 id=\"project-밤-하늘-별-출사-사진-특화-웹-서비스\">Project: 밤 하늘 별 출사, 사진 특화 웹 서비스<\/h4><p>정말 보편적인 To-do 아이템으로 마친 first project에 생애 첫 프로젝트의 맛을 봤다면, 이번 final project에서는 특색이 있으면서도 특정 사람들의 니즈를 충족시켜줄 수 있는 웹을 구축해보기로 했다. \n팀원들 각자 아이디어를 들고왔으며, 주어진 시간 내에 완성도를 높게 달성할 수 있는 아이디어로 선정하고 진행하기로 했다. <\/p><p>여러가지 아이디어들이 나왔고, 여러가지를 고려하여 최종적으로 &quot;밤 하늘 별을 담은 사진 모음 웹&quot;을 구축하기로 하였다. 따지고 보면 pintrest 혹은 그 외 여러가지 테마의 사진, gif 모음 웹이 있고, 많은 사용자들이 그러한 웹을 통해 자신의 ppt 등 자료에 활용하곤 한다.<\/p><p>어떻게 보면 이것 역시 To-do와 비슷하게 보편적인 웹으로 보인다. 하지만 등산을 좋아하는 사람들에겐 &#39;oo산 풍경&#39;을 담은 사진을 보며 대리만족하게 해주고, 그 사진의 장소 공유, 마치 같은 관심사를 가진 사용자들만의 공간은 그리 보편화되어있지 않아 보였다. 그래서 과감히 특정 관심사를 가진 특정 사람들을 위한 싸이월드 혹은 인스타 구축하기로 했다. \n<strong>우리는 밤하늘의 감성과 별을 좋아하는, 별 출사를 취미로 가진 사람들을 타겟으로 하여 별 출사에 맞게 웹 전반적으로 다크테마를 중심으로 별 사진들을 배열하여 사용자들에게 제공하기로 했다.<\/strong><\/p><h4 id=\"개발-방식\">개발 방식<\/h4><p>이번에 우리에게 주어진 시간은 4주, SR 끝내면 코드를 작성하는 시간은 정작 3주. 그래도 2주 프로젝트보다는 주어진 시간이 많다. 지난 프로젝트 당시 SR을 꼼꼼하게 하지 않은 탓에 코드를 한참 작성하는 도중 기능 flow가 점점 꼬이게 되는 현상을 발견하게 되어 긴급회의를 가진 후 새벽 5시까지 코드 재정비한다고 고생했던 기억을 교훈으로 삼아 이번에는 SR에 집중도를 높이기로 했다. 물론 개발을 진행하다보면 불가피하게 수정을 해야할 일이 많을 것이다. 하지만 이번엔 애자일 방법론을 도입하여 SR에서 예상치 못했던 부분들을 보완하기로 했다. <\/p><p><strong><em>애자일 방법론<\/em><\/strong>\n애자일 방법론이란 짧은 주기로 사용자가 사용 할 수 있는 소프트웨어를 만들어가면서 커뮤니케이션의 비용을 최소화하고 이슈 사항들을 바로 바로 제거하면서 개발하는 방식.\n예를 들면, 베타버젼으로 서비스를 출시 한 후 즉각적인 사용자들의 피드백을 반영해 곧바로 수정에 이어지게 한다. 이러한 과정이 반복되면서 완성도를 높이며 동시에 사용자의 신뢰도 얻는 방식.\n베타버젼 없이 장기간 개발작업 후 바로 정식버전으로 출시하는 &#39;폭포수 방식&#39;과 반대되는 개념이다.\n참고: <a href=\"https://brunch.co.kr/@insuk/5\">https://brunch.co.kr/@insuk/5<\/a><\/p><h4 id=\"역할\">역할<\/h4><p><strong>프론트엔드 개발자<\/strong>를 꿈꾸는 나는 first project와 마찬가지로 이번 final project에서도 프론트엔드를 맡기로 했다. 나를 포함해 총 3명이 프론트엔드를 맡았고, 나머지 1명은 백엔드의 역할을 맡으며 티키타카하면서 개발을 하기로 했다. <\/p><p>이번 프로젝트에서도 지난 번과 같이 로그인 관련, 각 종 모달을 맡았으며 유저 정보 관리를 담당하였다. \n지난 프로젝트보다 더 많은 기능이 추가되었고, 전반적으로 모달로 진행하기로 하여서 많은 시간을 투자해야할 것만 같다.<\/p><p>또한 많아진 컴포넌트들로 인해 상태관리가 복잡해질 것 같은데.. Redux를 도입할 것인지 오로지 React로만 해결해볼 것인지 고민도 해보았다. 결론은 <strong>React로만 상태관리를 해보자!<\/strong>이다.\n그 이유는 리액트에 대한 보다 깊은 연구가 필요했고, 그 만큼 React의 능숙도를 높이고 싶어서이다. <\/p><p>분명.. 이번 프로젝트 마치고나면 Redux의 도입을 그 누구보다도 더 적극적으로 주장하고 있지않을까싶지만.. 그래도 피나 철철 나도 피가 굳고 딱지가 떨어져나가면 굳은 살이 되듯이, 나의 성장을 위해 이번엔 Redux 없이 React만으로 상태관리를 해보겠다!!<\/p><p>자, 이번 프로젝트도 즐겁게 시작해보자!! \n<img src=\"https://images.velog.io/images/potter/post/38998168-75ae-4a70-9797-88f0545799cc/%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%92%E1%85%A1%E1%84%85%E1%85%AE.jpg\" alt=\"\"><\/p><hr><h4 id=\"2-final-project-1주차-회고\">2. [Final Project] 1주차 회고<\/h4><h4 id=\"✨-회고-및-팀원간-피드백-1\">✨ 회고 및 팀원간 피드백<\/h4><p>부트캠프에서 한 주를 마무리하면서 회고 및 팀원간 피드백을 권하여, 깃허브 issue에 각자 회고와 그 게시글의 댓글에 솔직한 피드백을 남겨주기로 했다. <\/p><h4 id=\"🌱-회고-1\">🌱 회고<\/h4><h4 id=\"fact-사실--주요-사건에서-내가-취한-행동을-객관적으로-서술한다\">Fact (사실) : 주요 사건에서 내가 취한 행동을 객관적으로 서술한다<\/h4><ul><li>wire frame, work flow, 스키마 작성 등  SR 관련 팀 회의<\/li><\/ul><h4 id=\"feeling-느낌--그때-느꼈던-기분을-간략히-정리한다\">Feeling (느낌) : 그때 느꼈던 기분을 간략히 정리한다<\/h4><ul><li>first project 당시 겪었던 교훈으로 더 세부적이고 부드러운 SR을 세우고자 노력했고, 그 노력으로 탄탄한 전략이 나온 듯 했다.<\/li><li>특히 스키마 작성 당시, 내가 복습만 더 해왔더라면 도움이 되었을텐데라는 아쉬움이 남았다. <\/li><\/ul><h4 id=\"finding-교훈--사건에서-얻은-교훈을-적는다-1\">Finding (교훈) : 사건에서 얻은 교훈을 적는다<\/h4><ul><li>프론트엔드라고 백엔드 공부를 소홀히 하면 안된다는 것을 프로젝트마다 느낀다. <\/li><li>욕심이 너무 과해 오히려 팀 회의에 독이 된게 아닌가 모르겠다. 그래도 팀원들간 적극적인 논의 끝에 좀 더 부드럽고 탄탄한 SR이 탄생하지 않나 싶다. 프로젝트를 진행하다보면 지난번처럼 다시 손보게 되겠지만, 정상적인 발전적인 방향이므로 부정적으로 생각하지 말기!<\/li><\/ul><h4 id=\"future-action행동--그래서-내가-앞으로-취할-행동을-미래형으로-적는다-1\">Future action(행동) : 그래서 내가 앞으로 취할 행동을 미래형으로 적는다<\/h4><ul><li><p>좀 더 적극적인 태도로 참여<\/p><\/li><li><p>끝까지 책임감 가지고 해내기<\/p><\/li><li><p>뭐든 즐거워하기! 좌절은 곧 팀에게 영향이 간다는 것을 명심명심명심!!<\/p><\/li><li><p>텐션 떨어지면 박보영 보고오기<\/p><\/li><li><p>코딩은 피아노 연주처럼 아름답게 :)<\/p><\/li><\/ul><h4 id=\"🌱-피드백-from-팀원-1\">🌱 피드백 From 팀원<\/h4><p><strong>JCxxx - commented on 28 Nov 2020<\/strong>\n스키마에 대한 것은 oo님이나 저한테 말씀드리면 이해하실때까지 알려드리겠습니다 ㅎㅎ 교훈에서 하신 말씀처럼 저도 프론트엔드에 공부를 소홀히하면 안될 것 같습니다. 컴포넌트 설계에서 뇌정지가 많이 오더라구요 😭\n욕심에 대해 회의에 독이 된 적 한 번도 없었습니다<del>! 왜 그렇게 생각하셨는지.. 적극적인 피드백과 의견이 저희 팀의 원동력이라 생각합니다<\/del>!! 다음 주부터 같이 힘내서 해봐요! 😆<\/p><p><strong>latxxx - commented on 28 Nov 2020<\/strong>\n가장 신중하면서 냉철하게 상황을 판단해주시는 재훈님 덕분에 SR 설계가 원활하게 이뤄졌다고 생각합니다!! 그리고 무엇보다도 팀 프로젝트의 가장 씨앗이라고 할 수 있는 &#39;별**&#39;에 대한 아이디어 hook 만으로도 재훈님께서 8할 이상의 기여를 해주셨다고 생각합니다 ☺️ 지난 2주 프로젝트에서처럼 이번 프로젝트에서도 재훈님의 압도적인 프론트엔드 개발 기여를 기대합니다!! 우리 화이팅<del>~<\/del> 😸<\/p><h4 id=\"🌱-마치며\">🌱 마치며<\/h4><p>우려스러운 부분도 많았지만, 팀원간 서로 부족한 부분을 채워주고 서로의 능력을 마음껏 발산할 수 있도록 힘을 실어준 한 주였다. 서로간의 커뮤니케이션의 중요성을 다시 한 번 느꼈으며, 지금 이 초심 끝까지 유지할 수 있도록 노력해야겠다. 파이팅!!<\/p><hr><h4 id=\"3-final-project-2주차-회고\">3. [Final Project] 2주차 회고<\/h4><p><img src=\"https://images.velog.io/images/potter/post/34de2d07-b660-4ceb-b17c-1d427a362528/image.png\" alt=\"\"><\/p><h4 id=\"✨-회고-및-팀원간-피드백-2\">✨ 회고 및 팀원간 피드백<\/h4><p>부트캠프에서 한 주를 마무리하면서 회고 및 팀원간 피드백을 권하여, 깃허브 issue에 각자 회고와 그 게시글의 댓글에 솔직한 피드백을 남겨주기로 했다. <\/p><h4 id=\"🌱-회고-2\">🌱 회고<\/h4><h4 id=\"fact-사실--주요-사건에서-내가-취한-행동을-객관적으로-서술한다-1\">Fact (사실) : 주요 사건에서 내가 취한 행동을 객관적으로 서술한다<\/h4><ul><li>각종 모달 구현 및 로그인 관련 기능 구현<\/li><\/ul><h4 id=\"feeling-느낌--그때-느꼈던-기분을-간략히-정리한다-1\">Feeling (느낌) : 그때 느꼈던 기분을 간략히 정리한다<\/h4><ul><li>first 때 했던거라 마냥 쉬울 줄 알았다. 너무 자만했다.<\/li><\/ul><h4 id=\"finding-교훈--사건에서-얻은-교훈을-적는다-2\">Finding (교훈) : 사건에서 얻은 교훈을 적는다<\/h4><ul><li>에러는 발전과정 중의 하나이며 나 스스로도 성장해나가는 원동력이다. 좌절하지말자.<\/li><\/ul><h4 id=\"future-action행동--그래서-내가-앞으로-취할-행동을-미래형으로-적는다-2\">Future action(행동) : 그래서 내가 앞으로 취할 행동을 미래형으로 적는다<\/h4><ul><li>다양한 환경 및 코드 flow에 다양한 에러를 만나고 있다. 에러를 능숙하게 다루는 훈련을 해야겠다.<\/li><\/ul><h4 id=\"🌱-피드백-from-팀원-2\">🌱 피드백 From 팀원<\/h4><p><strong>latxxx<\/strong>\n모달부터 컴포넌트 상속들에 이르기까지, 이미 지대한 결과물을 보여주신만큼, 조금은 페이스조절 하셔서 여유와 건강을 챙기셨으면 좋겠습니다!! 재훈님 덕분에 이 컴포넌트, 저 컴포넌트에서 정말 많은 도움을 받고 있습니다. ☺️ 1,2주차 감사했습니다!<\/p><p><strong>jswxxx<\/strong>\n충분히 잘 하고 계시고, 결국엔 해결이 될 것을 믿습니다. 날로 늘어가는 에러때문에 많이 힘드시겠지만 혹시나 도움드릴 수 있는 것은 꼭 돕겠습니다. 화이팅입니다!<\/p><p><strong>JCxxx<\/strong>\nFirst Project 때 처럼 같이 차근차근 해결해나가봅시다!<\/p><h4 id=\"🌱-마치며-1\">🌱 마치며<\/h4><p>역시 프로젝트 시작하면서 우려했던대로 컴포넌트들이 많아지고 상태관리가 복잡해지면서 state-props 경로가 꼬이기 시작했다. 같은 모달이지만 부모-자식 컴포넌트로 구성일 때도 있었으며, 형제 컴포넌트일 경우도 있었다. \n모달로 이루어진 홈페이지라 이중삼중 모달을 관리해야할 때가 많았기 때문이다. \n후.. 리액트를 배우려면 모달을 다뤄보길 권한다..<\/p><hr><h4 id=\"4-final-project-3주차-회고\">4. [Final Project] 3주차 회고<\/h4><p><img src=\"https://images.velog.io/images/potter/post/a8fac189-f5bd-4a67-8420-ec20628f8c80/image.png\" alt=\"\"><\/p><h4 id=\"✨-회고-및-팀원간-피드백-3\">✨ 회고 및 팀원간 피드백<\/h4><p>부트캠프에서 한 주를 마무리하면서 회고 및 팀원간 피드백을 권하여, 깃허브 issue에 각자 회고와 그 게시글의 댓글에 솔직한 피드백을 남겨주기로 했다.<\/p><h4 id=\"🌱-회고-3\">🌱 회고<\/h4><h4 id=\"fact-사실--주요-사건에서-내가-취한-행동을-객관적으로-서술한다-2\">Fact (사실) : 주요 사건에서 내가 취한 행동을 객관적으로 서술한다<\/h4><ul><li>AWS에러,502에러,CORS에러,Token 사라지는 현상<\/li><\/ul><h4 id=\"feeling-느낌--그때-느꼈던-기분을-간략히-정리한다-2\">Feeling (느낌) : 그때 느꼈던 기분을 간략히 정리한다<\/h4><ul><li>에러의 원인을 도저히 찾을 수가 없어서 처음에는 많이 당황했다.<\/li><li>이제는 무덤덤하다 <\/li><\/ul><h4 id=\"finding-교훈--사건에서-얻은-교훈을-적는다-3\">Finding (교훈) : 사건에서 얻은 교훈을 적는다<\/h4><ul><li>CORS 에러는 다양한 곳에서 일어나는 것을 알게되었다. <\/li><li>에러를 만나더라도 다양한 추론으로부터 시작해야함을 다시 한 번 깨달았다.<\/li><li>비록 프론트를 맡고있지만 서버 공부도 끊임없이 해야 위와 같은 에러 핸들링도 수월하다는 것을 알게되었다.<\/li><li>백엔드 개발자 분과 꾸준한 의사소통 또한 중요함을 깨달았다.<\/li><\/ul><h4 id=\"future-action행동--그래서-내가-앞으로-취할-행동을-미래형으로-적는다-3\">Future action(행동) : 그래서 내가 앞으로 취할 행동을 미래형으로 적는다<\/h4><ul><li>백엔드 관련 공부를 꾸준히 해야겠다.<\/li><li>지금보다 더 적극적인 의사소통을 팀원과 나눠야겠다.<\/li><\/ul><h4 id=\"🌱-피드백-from-팀원-3\">🌱 피드백 From 팀원<\/h4><p><strong>latxxx<\/strong>\n로그인과 세션, 토큰에 대해 이번 프로젝트를 통해 폭넓고 깊게 체득하신 것 같아서 그저 부러울 따름입니다. 재훈님께서 작성하신 코드를 통해 저도 많은 공부를 해야겠다는 생각이 들었습니다. 프론트엔드 모든 테스트의 시발점을 멋지게 컨트롤해주셔서 감사드립니다. ☺️<\/p><p><strong>JCxxx<\/strong>\n같이 CORS나 쿠키, 세션에 대해 대화를 많이 나눠서 보안과 리액트에 대해 많이 공부할 수 있었습니다. 남은 기간 여러 주제에 대해 대화를 많이 나눌 수 있으면 좋겠습니다!<\/p><p><strong>jswxxx<\/strong>\n저도 함게 노력하며 재훈님이 겪으시는 문제를 해결하고 싶지만, 이제는 무슨 말인지 못알아듣는 경지까지 온 것 같습니다ㅠㅠ 하지만 내용을 들을 때마다 얼마나 많은 노력을 기울이시는지 알 수 있습니다ㅠㅠ CORS에 룰이 있기는 한지가 의심스러운 상황에서도 끝까지 노력하시는 모습을 존경합니다. 늘 화이팅입니다!<\/p><h4 id=\"🌱-마치며-2\">🌱 마치며<\/h4><p>퍼스트 프로젝트에서 다룬 로그인은 그저 물에 발가락만 퐁당 담궜다 뺀 것에 불과했다.\njwt를 도입해 accesstoken을 다루는 그 과정에 만난 각종 에러들.. \n어휴 개발자도구창이 빨간색으로 도배되었을 때의 기분은 정말.. 아름답다!!!<\/p><hr><p>4주차 회고는 해당 포스트의 메인 주제로, 최상단에 올라가시면 확인이 가능합니다.<\/p><p>새해 복 듬뿍 받으세요!! :)<\/p>"
      },
      {
        "title": "[Final Project] 3주차 회고",
        "link": "https://velog.io/@potter/final-project-3%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0",
        "guid": "https://velog.io/@potter/final-project-3%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0",
        "pubDate": "Sat, 19 Dec 2020 07:12:59 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/a8fac189-f5bd-4a67-8420-ec20628f8c80/image.png\" alt=\"\"><\/p><h1 id=\"✨-회고-및-팀원간-피드백\">✨ 회고 및 팀원간 피드백<\/h1><p>부트캠프에서 한 주를 마무리하면서 회고 및 팀원간 피드백을 권하여, 깃허브 issue에 각자 회고와 그 게시글의 댓글에 솔직한 피드백을 남겨주기로 했다.<\/p><h2 id=\"🌱-회고\">🌱 회고<\/h2><h3 id=\"fact-사실--주요-사건에서-내가-취한-행동을-객관적으로-서술한다\">Fact (사실) : 주요 사건에서 내가 취한 행동을 객관적으로 서술한다<\/h3><ul><li>AWS에러,502에러,CORS에러,Token 사라지는 현상<\/li><\/ul><h3 id=\"feeling-느낌--그때-느꼈던-기분을-간략히-정리한다\">Feeling (느낌) : 그때 느꼈던 기분을 간략히 정리한다<\/h3><ul><li>에러의 원인을 도저히 찾을 수가 없어서 처음에는 많이 당황했다.<\/li><li>이제는 무덤덤하다 <\/li><\/ul><h3 id=\"finding-교훈--사건에서-얻은-교훈을-적는다\">Finding (교훈) : 사건에서 얻은 교훈을 적는다<\/h3><ul><li>CORS 에러는 다양한 곳에서 일어나는 것을 알게되었다. <\/li><li>에러를 만나더라도 다양한 추론으로부터 시작해야함을 다시 한 번 깨달았다.<\/li><li>비록 프론트를 맡고있지만 서버 공부도 끊임없이 해야 위와 같은 에러 핸들링도 수월하다는 것을 알게되었다.<\/li><li>백엔드 개발자 분과 꾸준한 의사소통 또한 중요함을 깨달았다.<\/li><\/ul><h3 id=\"future-action행동--그래서-내가-앞으로-취할-행동을-미래형으로-적는다\">Future action(행동) : 그래서 내가 앞으로 취할 행동을 미래형으로 적는다<\/h3><ul><li>백엔드 관련 공부를 꾸준히 해야겠다.<\/li><li>지금보다 더 적극적인 의사소통을 팀원과 나눠야겠다.<\/li><\/ul><h2 id=\"🌱-피드백-from-팀원\">🌱 피드백 From 팀원<\/h2><p><strong>latxxx<\/strong>\n로그인과 세션, 토큰에 대해 이번 프로젝트를 통해 폭넓고 깊게 체득하신 것 같아서 그저 부러울 따름입니다. 재훈님께서 작성하신 코드를 통해 저도 많은 공부를 해야겠다는 생각이 들었습니다. 프론트엔드 모든 테스트의 시발점을 멋지게 컨트롤해주셔서 감사드립니다. ☺️<\/p><p><strong>JCxxx<\/strong>\n같이 CORS나 쿠키, 세션에 대해 대화를 많이 나눠서 보안과 리액트에 대해 많이 공부할 수 있었습니다. 남은 기간 여러 주제에 대해 대화를 많이 나눌 수 있으면 좋겠습니다!<\/p><p><strong>jswxxx<\/strong>\n저도 함게 노력하며 재훈님이 겪으시는 문제를 해결하고 싶지만, 이제는 무슨 말인지 못알아듣는 경지까지 온 것 같습니다ㅠㅠ 하지만 내용을 들을 때마다 얼마나 많은 노력을 기울이시는지 알 수 있습니다ㅠㅠ CORS에 룰이 있기는 한지가 의심스러운 상황에서도 끝까지 노력하시는 모습을 존경합니다. 늘 화이팅입니다!<\/p><h2 id=\"🌱-마치며\">🌱 마치며<\/h2><p>퍼스트 프로젝트에서 다룬 로그인은 그저 물에 발가락만 퐁당 담궜다 뺀 것에 불과했다.\njwt를 도입해 accesstoken을 다루는 그 과정에 만난 각종 에러들.. \n어휴 개발자도구창이 빨간색으로 도배되었을 때의 기분은 정말.. 아름답다!!!<\/p>"
      },
      {
        "title": "[프로젝트 일지] CSS",
        "link": "https://velog.io/@potter/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9D%BC%EC%A7%80-CSS",
        "guid": "https://velog.io/@potter/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9D%BC%EC%A7%80-CSS",
        "pubDate": "Tue, 15 Dec 2020 21:26:29 GMT",
        "description": "<p>로그인 및 유저 파트를 담당하고 있는 나는 이제 각종 버그 및 UX/UI를 위한 CSS를 업데이트 시키고 있다.\nreact를 완성시키고 나니 이제는 CSS의 커다란 벽에 부딪혀 머리가 깨지고 있는 상황이다. \n이게... 미적감각도 어느정도 있어야할 것 같고.. CSS 자체가 그냥.. 뭐..<\/p><p>그냥 다 힘들다.. 모르겠다 모두..<\/p>"
      },
      {
        "title": "[알고리즘]프로그래머스 - 이상한 문자 만들기",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0",
        "pubDate": "Tue, 15 Dec 2020 21:20:19 GMT",
        "description": "<h1 id=\"이상한-문자-만들기\">이상한 문자 만들기<\/h1><p>주어진 문제에 들어오는 파라미터는 소문자로 구성이 된 string이다.\n이 string의 각 단어마다 짝수번째의 알파벳을 대문자로 변환하고 리턴하면 되는 문제이다.<\/p><h4 id=\"문제-출처-프로그래머스\">문제 출처: 프로그래머스<\/h4><p><img src=\"https://images.velog.io/images/potter/post/f15698c3-58b2-4309-af72-d4dd00fbc75d/image.png\" alt=\"\"><\/p><h2 id=\"풀이\">풀이<\/h2><ol><li>split(&quot; &quot;) : 들어오는 문자열을 각 단어로 나눈 후 배열을 이루게 한다.<\/li><li>map(): 그 후 각 인자 하나하나를 손쉽게 들여다보고 원하는 값으로 맵핑하기 위해 map을 사용한다.\n주의할 점은 map()은 기존 값은 변하지않으니, 새로운 변수에 담도록 한다.<\/li><li>for 반복문: map을 사용하면서 반복문을 돌며 각 단어의 짝수번째 알파벳을 대문자로 변환시키는 작업을 한다. 여기서 answer이라는 변수를 전역에 놓지말고, map안의 최 상단에 위치시킨다. 그 후 각 단어의 대문자 변환작업을 마치면 다음 단어로 이동하기 전 answer의 값을 빈 문자열로 초기화 시킨다. (이 부분에서 많이 헤맸음.) 이미 바로 직전에 작업이 끝난 answer은 새로운 map의 배열에 저장이 되었기 때문이며, 초기화를 안하면 직전에 끝난 값들이 이제 시작할 다음 단어와 합쳐지져 [&#39;TrY&#39;, &#39;TrYhElLo, ...]가 되기 때문이다.<\/li><li>join(): 공백도 존재하는 문자열로 만든다. 그리고 리턴한다.<\/li><\/ol><h2 id=\"구현\">구현<\/h2><pre><code class=\"language-javascript\">function solution(s) {\n\n    let split = s.split(&quot; &quot;)  //     [ &#39;try&#39;, &#39;hello&#39;, &#39;world&#39; ]\n\n    let res = split.map(item =&gt; {\n        let answer = &#39;&#39;;\n        let length = item.length\n        for(let i = 0; i &lt; length; i++) {\n            if(i%2 === 0) {\n                answer += item[i].toUpperCase()\n            }\n            else {\n                answer += item[i].toLowerCase()\n            }\n        }\n        return answer\n    })\n    console.log(res) // [ &#39;TrY&#39;, &#39;HeLlO&#39;, &#39;WoRlD&#39; ]\n  return res.join(&quot; &quot;)\n\n    // return answer;\n}<\/code><\/pre>"
      },
      {
        "title": "[알고리즘]프로그래머스 h-index",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-h-index",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-h-index",
        "pubDate": "Tue, 15 Dec 2020 01:09:49 GMT",
        "description": "<h1 id=\"h-index\">H-index<\/h1><p> &quot;... 여기서 곡선과 직선이 만나는 점, 즉 한 연구자가 출판한 논문의 수와 인용의 수가 같은 점이 생기는데 이를 h 값이라고 하고, 곡선 아래의 전체 넓이는 이 연구자가 지금껏 출판한 모든 논문들의 모든 피인용수라고 할 수 있다. 정리하면, &quot;어떤 연구자의 h 인덱스 값이 h 일 때, 이 연구자의 논문 중 h 편이 h 회 이상 인용되었다.&quot;[2]&quot;   -위키백과-<\/p><p>즉 H-index란, 어느 학자를 평가를 할 때 발표한 논문 수와 인용된 횟수를 계산하여 평가를 하고 그 평가 지표가 되는 것이 H-index라고 한다.<\/p><p>그럼 문제를 살펴보자.<\/p><h4 id=\"문제-출처-프로그래머스\">문제 출처: 프로그래머스<\/h4><p><img src=\"https://images.velog.io/images/potter/post/b6dcd44c-2a49-4e16-ac82-11dc7acc1bfc/image.png\" alt=\"\"><\/p><p>위의 입출력 예를 보면 \n어떤 과학자가 발표한 논문의 수는 5편이고, 그 중 3편의 논문은 3회 인용이 된 것으로 확인이 된다.\n이 때 그 3편의 논문이 곧 그 과학자의 H-index가 된다고 볼 수 있다.<\/p><h2 id=\"풀이\">풀이<\/h2><p>citations 배열: 논문을 보관하고 있는 책장\ncitaions.lengt+1 : 발표한 논문의 총 수\ni+1: 책장 안에 있는 각 논문의 책 넘버\ncitations로 들어오는 배열의 인자 : 각각 인용된 횟수<\/p><ol><li>sort의 내림차순으로 배열을 정렬한다. 인용이 많이 된 논문부터 &quot;1권&quot;이라는 index num을 붙이기 위함.<\/li><li>정렬된 배열에서 인용된 횟수와 논문의 넘버(각 index에 +1 을 한 값)를 비교한다.<\/li><li>논문의 넘버(index+1)가 인용된 횟수보다 같거나 작아지는 순간 그 전의 논문의 넘버(index+1)을 리턴하도록 한다.<\/li><\/ol><h2 id=\"구현\">구현<\/h2><pre><code class=\"language-javascript\">function solution(citations) {\n    // sort로 citations배열을 내림차순으로 정렬을 한다.\n    // for문으로 인덱스값 하나하나를 비교를 한다\n    // index+1(발표된 논문의 수) &lt;= 각 인자(인용된 횟수)\n    // 리턴==&gt;index+1\n\n    let answer = 0;\n    let length  = citations.length;\n\n    citations.sort((a,b) =&gt; {\n        return b - a\n    })\n    // console.log(citations)\n\n\n    for(let i = 0; i &lt; length; i++) {\n        if(citations[i] &gt;= i+1) {\n            answer = i+1 \n            // 6 &gt;= 1 5,2 3,3 1,4\n        }\n    }\n\n    return answer;   \n}<\/code><\/pre><h2 id=\"마치며\">마치며..<\/h2><p>인간관계도 코딩과 같다고 느껴지는 요즘이다.\n코딩에서 에러를 만나는 순간 어디서부터 잘못된 것인지 찾아야하고, 그 잘못된 지점부터 차근차근 풀어나가면 되겠지만 그 과정도 쉽지가 않고, 그 해결과정에서 또 꼬여버리면 돌이킬 수 없는 길을 건너게 된다.\n인간관계도 마찬가지인 것 같다. 그 사람과 갈등을 해소하고 예전처럼 잘지내고 싶은데도.. 무엇인가 나의 눈을 가리고 올바르지 않는 방향으로 이끄는 것만 같다. 하루하루가 괴로운 날들의 연속이다.<\/p>"
      },
      {
        "title": "[CSS] border가 안보일때",
        "link": "https://velog.io/@potter/CSS-border%EA%B0%80-%EC%95%88%EB%B3%B4%EC%9D%BC%EB%95%8C",
        "guid": "https://velog.io/@potter/CSS-border%EA%B0%80-%EC%95%88%EB%B3%B4%EC%9D%BC%EB%95%8C",
        "pubDate": "Mon, 14 Dec 2020 11:53:12 GMT",
        "description": "<p>table style 적용 여부부터 확인하기.<\/p><pre><code class=\"language-javascript\">     border: solid rgb(143, 143, 143);\n     border-width: 10px;\n     border-radius: 10px;<\/code><\/pre><p>  SOLID!!!!!!!!!!!!!!!!<\/p>"
      },
      {
        "title": "[프로젝트 일지]스크롤 상단 이동",
        "link": "https://velog.io/@potter/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9D%BC%EC%A7%80%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%83%81%EB%8B%A8-%EC%9D%B4%EB%8F%99",
        "guid": "https://velog.io/@potter/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9D%BC%EC%A7%80%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%83%81%EB%8B%A8-%EC%9D%B4%EB%8F%99",
        "pubDate": "Mon, 14 Dec 2020 09:07:13 GMT",
        "description": "<p>인피니티 스크롤로 개발 중인 우리 프로젝트에 만약 사용자가 최하단에 위치했을 경우 혹은 현 위치에서 최상단으로 손쉽게 이동하고자 ux/ui를 수정하고 있었다.<\/p><p>금방 끝날 줄 알았던 이 기능이 의외로 오래걸렸고, <\/p><pre><code class=\"language-javascript\">document.querySelector(&#39;.flex&#39;).scrollIntoView({ behavior: &#39;smooth&#39; });<\/code><\/pre><p>위의 한 줄로 끝나버렸다.<\/p><p>물론 리액트에서는 위의 방식을 지양하는 것 같아 리액트에서 제공하는 라이브러리를 사용하던가 등등 다시 시도를 해볼 필요성이 있어 보인다<\/p><p>아무튼\n너무나 허무한 것.. <\/p><p>참고:\n<a href=\"http://iamdustan.com/smoothscroll/\">http://iamdustan.com/smoothscroll/<\/a><a href=\"https://enai.tistory.com/33\">https://enai.tistory.com/33<\/a><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo\">https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo<\/a><a href=\"https://gracefullight.dev/2018/02/08/react%EC%97%90%EC%84%9C-scrollTo-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A1%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%9D%B4%EB%8F%99%EC%9D%B4-%EC%95%88%EB%90%A0-%EB%95%8C/\">https://gracefullight.dev/2018/02/08/react%EC%97%90%EC%84%9C-scrollTo-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A1%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%9D%B4%EB%8F%99%EC%9D%B4-%EC%95%88%EB%90%A0-%EB%95%8C/<\/a><\/p>"
      },
      {
        "title": "[알고리즘] LeetCode - Move Zeroes",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-LeetCode-Move-Zeroes",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-LeetCode-Move-Zeroes",
        "pubDate": "Sun, 13 Dec 2020 14:45:34 GMT",
        "description": "<p><img src=\"https://images.velog.io/images/potter/post/1c6a1305-de39-4279-9253-438a916ea080/image.png\" alt=\"\"><\/p><pre><code class=\"language-javascript\">/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n\n    let length = nums.length;\n    let count = 0;\n    let temp\n\n    for(let i = 0; i &lt; length; i++) {\n        if(nums[i] === 0) {\n            count++\n            continue\n        }\n        if(nums[i-count]=== 0) {\n            temp = nums[i];\n            nums[i] = nums[i-count];\n            nums[i-count] =temp;\n\n        }\n    }\n    return nums\n\n};<\/code><\/pre><p>ㄱㅈㅇ..<\/p>"
      },
      {
        "title": "[알고리즘] K번째 수",
        "link": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-K%EB%B2%88%EC%A7%B8-%EC%88%98",
        "guid": "https://velog.io/@potter/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-K%EB%B2%88%EC%A7%B8-%EC%88%98",
        "pubDate": "Wed, 09 Dec 2020 21:34:00 GMT",
        "description": "<p>문제 출처: 프로그래머스<\/p><p>문제 설명\n배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.<\/p><p>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면<\/p><p>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\n1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\n2에서 나온 배열의 3번째 숫자는 5입니다.\n배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.<\/p><p>제한사항\narray의 길이는 1 이상 100 이하입니다.\narray의 각 원소는 1 이상 100 이하입니다.\ncommands의 길이는 1 이상 50 이하입니다.\ncommands의 각 원소는 길이가 3입니다.\n입출력 예\narray    commands    return\n[1, 5, 2, 6, 3, 7, 4]    [[2, 5, 3], [4, 4, 1], [1, 7, 3]]    [5, 6, 3]\n입출력 예 설명\n[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\n[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\n[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.<\/p><pre><code class=\"language-javascript\">function solution(array, commands) {\n    let answer = [];\n    let temp = [];\n    let length = commands.length;\n    console.log(length)\n\n    for(let i = 0; i &lt; length; i++) {\n\n        temp.push(array.slice(commands[i][0]-1, commands[i][1]).sort((a, b) =&gt; a - b ))\n        temp = temp.flat()\n\n        answer.push(temp[commands[i][2]-1])\n        temp = []\n        console.log(&quot;temp&quot;, temp)\n        console.log(&quot;answer&quot;, answer)\n    }\n    // answer.push(array.splice(commands[1][0]-1, commands[1][1] - commands[1][0]+1))\n    // console.log(answer)\n    return answer\n\n\n    // return answer;\n}<\/code><\/pre>"
      }
    ]
  }
}